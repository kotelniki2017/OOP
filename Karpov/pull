class node
{
 public:
  node();
  void set_next (node* );
  void set_prev (node* );
  void set_value (int value);
  node* get_next ();
  node* get_prev ();
  int get_value ();
 private:
  int value;
  node* next;
  node* prev;
};

class pull
{
 public:
  pull (int );
  ~pull ();
  node get_pull (int );
 private:
  int n;
  node* ar;
};
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include <iostream>
#include "pull.h"
using namespace std;
node :: node ()
{
  value = 0;
  next = NULL;
  prev = NULL;
}

int node :: get_value ()
{
  return value;
}

node* node :: get_prev ()
{
  return prev;
}

node* node :: get_next ()
{
  return next;
}

void node :: set_next (node* p)
{
  next = p;
}

void node :: set_prev (node* p)
{
  prev = p;
}

void node :: set_value (int x)
{
  value = x;
}

pull :: pull (int x)
{
  if (x > 0)
    {
      n = x;
      ar = new node [n];
      for (int i = 0; i < n; i++)
	{
	  if (i == 0)
	    {
	      ar[0].set_prev (NULL);
	      if (n != 1)
		ar[0].set_next (&ar[1]);
	      else
		ar[0].set_next (NULL);
	      ar[0].set_value (0);
	      continue;
	    }
	  if (i == (n - 1))
	    {
	      if (n != 1)
		{
		  ar[n - 1].set_next (NULL);
		  ar[n - 1].set_prev (&ar[n - 2]);
		  ar[n - 1].set_value (n - 1);
		}
	      continue;
	    }
	  ar[i].set_next (&ar[i + 1]);
	  ar[i].set_prev (&ar[i - 1]);
	  ar[i].set_value (i);
	}
    }
  else
    cout << "Ошибка создания пула";
}

node pull :: get_pull (int x)
{
  if ((x >= 0) && (x < n))
    return ar[x];
}

pull :: ~pull ()
{
  delete [] ar;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include <iostream>
#include "pull.h"
using namespace std;

int main()
{
  pull T(10);
  for (int i = 0; i < 10; i++)
    cout << T.get_pull (i).get_value () << endl;
  cout << endl;
  node* p = T.get_pull (1).get_prev ();
  while (p != NULL)
    {
      cout << p -> get_value () << endl;
      p = p -> get_next ();
    }
  return 0;
}
